(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{361:function(s,e,n){"use strict";n.r(e);var t=n(43),a=Object(t.a)({},(function(){var s=this,e=s.$createElement,n=s._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("p",[s._v("mysql只支持一种join算法："),n("strong",[s._v("Nested-Loop Join")]),s._v("（嵌套循环连接），但Nested-Loop Join有三种变种：")]),s._v(" "),n("h2",{attrs:{id:"原理："}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原理："}},[s._v("#")]),s._v(" 原理：")]),s._v(" "),n("p",[n("strong",[s._v("1.Simple Nested-Loop Join")]),s._v("：")]),s._v(" "),n("p",[s._v("如下图，r为驱动表，s为匹配表，可以看到从r中分别取出r1、r2、......、rn去匹配s表的左右列，然后再合并数据，对s表进行了rn次访问，对数据库开销大")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/13/1670b735a4e95a50?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),s._v(" "),n("p",[n("strong",[s._v("2.Index Nested-Loop Join（索引嵌套）：")])]),s._v(" "),n("p",[s._v("这个要求非驱动表（匹配表s）上有索引，可以通过索引来减少比较，加速查询。")]),s._v(" "),n("p",[s._v("在查询时，驱动表（r）会根据关联字段的索引进行查找，挡在索引上找到符合的值，再回表进行查询，也就是只有当匹配到索引以后才会进行回表查询。")]),s._v(" "),n("p",[s._v("如果非驱动表（s）的关联健是主键的话，性能会非常高，如果不是主键，要进行多次回表查询，先关联索引，然后根据二级索引的主键ID进行回表操作，性能上比索引是主键要慢。")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/13/1670b7380034b628?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),s._v(" "),n("p",[n("strong",[s._v("3.Block Nested-Loop Join：")])]),s._v(" "),n("p",[s._v("如果有索引，会选取第二种方式进行join，但如果join列没有索引，就会采用Block Nested-Loop Join。")]),s._v(" "),n("p",[s._v("可以看到中间有个join buffer缓冲区，是将驱动表的所有join相关的列都先缓存到join buffer中，然后批量与匹配表进行匹配，将第一种多次比较合并为一次，降低了非驱动表（s）的访问频率。")]),s._v(" "),n("p",[s._v("默认情况下join_buffer_size=256K，在查找的时候MySQL会将所有的需要的列缓存到join buffer当中，包括select的列，而不是仅仅只缓存关联列。在一个有N个JOIN关联的SQL当中会在执行时候分配N-1个join buffer。")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/13/1670b7867b5dcb99?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),s._v(" "),n("h2",{attrs:{id:"实例："}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实例："}},[s._v("#")]),s._v(" 实例：")]),s._v(" "),n("p",[s._v("假设两张表a 和 b")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("a结构：\ncomments_id        bigInt(20)    P\nfor_comments_if    mediumint(9)\nproduct_id         int(11)\norder_id           int(11)\n...复制代码\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("b结构：\nid            int(11)       p\ncomments_id   bigInt(20)\nproduct_id    int(11)\n...复制代码\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[s._v("其中b的关联有comments_id，所以有索引。")]),s._v(" "),n("p",[n("strong",[s._v("1.join")]),s._v("：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("SELECT * FROM a gc\nJOIN b gcf ON gc.comments_id=gcf.comments_id\nWHERE gc.comments_id =2056复制代码\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("使用的是Index Nested-Loop Join，先对驱动表a的主键筛选，得到一条，然后对非驱动表b的索引进行seek匹配，预计得到一条数据。")]),s._v(" "),n("p",[s._v("下面这种情况没用到索引：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("SELECT * FROM a gc\nJOIN b gcf ON gc.order_id=gcf.product_id复制代码\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[s._v("使用Block Nested-Loop Join，如果b表数据少，作为驱动表，将b的需要的数据缓存到join buffer中，批量对a表扫描")]),s._v(" "),n("p",[n("strong",[s._v("2.left join：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("SELECT * FROM a gc\nLEFT JOIN b gcf ON gc.comments_id=gcf.comments_id复制代码\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[s._v("这里用到了索引，所以会采用Index Nested-Loop Join，因为没有筛选条件，会选择一张表作为驱动表去进行join，去关联非驱动表的索引。")]),s._v(" "),n("p",[s._v("如果加了条件")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("SELECT * FROM b gcf\nLEFT JOIN a gc ON gc.comments_id=gcf.comments_id\nWHERE gcf.comments_id =2056复制代码\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("就会从驱动表筛选出一条来进行对非驱动表的匹配。")]),s._v(" "),n("p",[s._v("left join：会保全左表数据，如果右表没相关数据，会显示null")]),s._v(" "),n("p",[s._v("fight join：会保全右表数据，如果左表没相关数据，会显示null")]),s._v(" "),n("p",[s._v("inner join：部分主从表，结果会取两个表针对on条件相匹配的最小集")])])}),[],!1,null,null,null);e.default=a.exports}}]);