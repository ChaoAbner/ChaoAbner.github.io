(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{356:function(t,s,a){"use strict";a.r(s);var r=a(43),n=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"python-动态加载模块和类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#python-动态加载模块和类"}},[t._v("#")]),t._v(" python - 动态加载模块和类")]),t._v(" "),a("p",[a("strong",[t._v("1，使用系统函数import()stringmodule = _import('string')")])]),t._v(" "),a("p",[a("strong",[t._v("2，使用importlib模块")]),t._v("\nimport importlib\nstringmodule = importlib.import_module('module_path')")]),t._v(" "),a("p",[a("strong",[t._v("3，使用exec")]),t._v("\nimport"),a("em",[t._v('string = "import string as stringmodule"exec import')]),t._v("string")]),t._v(" "),a("p",[t._v("import importlib")]),t._v(" "),a("p",[t._v("importlib是import的python实现")]),t._v(" "),a("p",[a("strong",[t._v("1、获取模块对象")]),t._v("\nm1 = importlib.import"),a("em",[t._v('module("sites.sites')]),t._v('pybuild")\nprint(m1)')]),t._v(" "),a("p",[t._v("输出：")]),t._v(" "),a("p",[a("strong",[t._v("2、获取类对象")])]),t._v(" "),a("p",[t._v('aclass = getattr(m1, "sites_pybuild")')]),t._v(" "),a("p",[t._v("print(aclass)")]),t._v(" "),a("p",[t._v("输出：")]),t._v(" "),a("p",[a("strong",[t._v("3、实例化对象")])]),t._v(" "),a("p",[t._v('p = aclass("test")\n相当于直接使用p = sites.sites'),a("em",[t._v("pybuild.sites")]),t._v('pybuild("test")')]),t._v(" "),a("p",[t._v('下面的文章也可以实现反射，主要思想是先导入module，然后使用globals()["classname"]获得类定义，再使用此类定义来初始化对象。')]),t._v(" "),a("p",[t._v("http://blog.csdn.net/lokibalder/article/details/3459722")]),t._v(" "),a("h2",{attrs:{id:"反射"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#反射"}},[t._v("#")]),t._v(" 反射")]),t._v(" "),a("p",[t._v("python是一个脚本语言，它不象java一样有一个专门的包来处理反射。以 下是我们来看看python是怎么做到类似java一样的反射功能的。我在网上搜了一下，因为在网上没有很明确的文章说要怎么做，所以，我写了这篇，希望 新手不要向我一样走弯路，因为是新手，所以，我在这里没能考虑到异常的处理。")]),t._v(" "),a("h3",{attrs:{id:"一、动态加载类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、动态加载类"}},[t._v("#")]),t._v(" 一、动态加载类")]),t._v(" "),a("p",[t._v("说到动态的加载类，那就不得不说，动态的加态模块。因为只能成功的加模了模块才能加载到类。我们可以用，以下的代码来动态的加载类\nPython代码\n＃modulePath是模块文件的路径+模块的文件名。\naMod = sys.modules[modulePath]\n当我们动态的加载了这个模块后，我们就可以从这个模块中取得你要的类了，感觉上这个方法有点像java中从类中反射出方法。下以的代码可以\nPython代码\naClass= getattr(aMod, className)")]),t._v(" "),a("h3",{attrs:{id:"二、动态实例化类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、动态实例化类"}},[t._v("#")]),t._v(" 二、动态实例化类")]),t._v(" "),a("p",[t._v("得到了class对象之后，在python就可以很方便的得到他的对像，以下这代码\nPython代码 obj = new.instance(aClass)")]),t._v(" "),a("h3",{attrs:{id:"三、得到对象、类或模块中的所有属性方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、得到对象、类或模块中的所有属性方法"}},[t._v("#")]),t._v(" 三、得到对象、类或模块中的所有属性方法")]),t._v(" "),a("p",[t._v("在java的反射中我们可以得到对象中的所有属性和方法，在python中，因为是脚本语言，所以我们要得到这个些属性方法更加的方便，我们可以用以下的代码获得类，对象，模块中的所有的属性的名称\nPython代码\ndir(aClass)\n我们得到这些属性的名称后，可以用上面得到class 的方法来获得这个对象里的所有属性")]),t._v(" "),a("h3",{attrs:{id:"四、动态运行方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、动态运行方法"}},[t._v("#")]),t._v(" 四、动态运行方法")]),t._v(" "),a("p",[t._v("动态的运行方法，我们也非常的方便，因为python是脚本语言，感觉起来很象javascript的方式来调用方法。\nPython代码\napply(objFunc,arrArgs)\n代码中objFunc是用getAttr从实例化后的对象中取得到function，而arrArgs是我们的参数，和javascript一样，他是数组一样的对象。")])])}),[],!1,null,null,null);s.default=n.exports}}]);