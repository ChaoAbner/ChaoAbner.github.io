(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{380:function(t,v,e){"use strict";e.r(v);var s=e(43),_=Object(s.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"redis总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis总结"}},[t._v("#")]),t._v(" Redis总结")]),t._v(" "),e("p",[e("strong",[t._v("1、redis和memcached的区别，为什么单线程的redis有时比memcached的效率高")])]),t._v(" "),e("p",[t._v("​\t\t1、memcached可以存储图片或者视频，redis支持key/value的很多数据结构")]),t._v(" "),e("p",[t._v("​\t\t2、redis可以使用虚拟内存。可以通过RDB和AOF进行持久化和灾难恢复。redis支持主从备份。")]),t._v(" "),e("p",[t._v("​\t\t3、redis可以做消息队列。")]),t._v(" "),e("p",[t._v("​\t\t原因："),e("strong",[t._v("memcached")]),t._v("多线程模型引入了"),e("strong",[t._v("缓存一致性")]),t._v("和"),e("strong",[t._v("锁")]),t._v("，"),e("strong",[t._v("加锁带来了性能损耗")]),t._v("。")]),t._v(" "),e("p",[e("strong",[t._v("2、redis 主从复制如何实现的？redis的集群模式如何实现？redis的key是如何寻址的？")]),e("img",{attrs:{src:"F:%5CtyporaImg%5C1582196748156.png",alt:"1582196748156"}})]),t._v(" "),e("p",[t._v("​\t\t寻址：http://blog.itpub.net/69917606/viewspace-2642545/")]),t._v(" "),e("p",[e("strong",[t._v("3、使用redis实现分布式锁？实现思路？使用zk可以吗？怎么实现？这两种有什么区别？")])]),t._v(" "),e("p",[t._v("​\t\t可以使用redis的setnx()方法")]),t._v(" "),e("p",[t._v("​\t\t1、线程A setnx()，设置超时时间t1，如果返回true，则获得锁")]),t._v(" "),e("p",[t._v("​\t\t2、线程B用get获取t1，判断是否超时。如果超时了，则执行第三步、没超时返回false。")]),t._v(" "),e("p",[t._v("​\t\t3、计算新的超时时间t2，使用getset()返回t3，如果t3==t1的话，则获得锁（CAS原理）。否则，说明锁被其它线程获取了。")]),t._v(" "),e("p",[t._v("​\t\t4、获取锁后，处理完业务逻辑，"),e("strong",[t._v("先判断锁是否超时")]),t._v("，如果没超时则删除锁，如果超时，不用处理。（防止删除其它线程获得的锁）。")]),t._v(" "),e("p",[e("strong",[t._v("4、redis的持久化？底层是怎么实现的？有什么优缺点？")])]),t._v(" "),e("p",[t._v("​\t\tRDB(redis database)：在不同时间点将redis的"),e("strong",[t._v("数据生成的快照同步到磁盘")]),t._v("等介质，定期更新。缺点：耗时，性能低（I/O），易丢失数据。（数据同步到磁盘）")]),t._v(" "),e("p",[t._v("​\t\tAOF(append only file): 将redis执行过的所有指令记录下来（记录执行指令）。下次重启时，只需要重新执行所有的指令。缺点：体积大，恢复速度慢。")]),t._v(" "),e("p",[e("strong",[t._v("5、redis过期策略有哪些？LRU算法的实现？")])]),t._v(" "),e("p",[t._v("​\t\t1、定时过期（定时清理过期的key）")]),t._v(" "),e("p",[t._v("​\t\t2、惰性过期（当用到key的时候才判断是否过期和是否清理）")]),t._v(" "),e("p",[t._v("​\t\t3、LRU算法（保证不常用的数据在队列的后面）原理FIFO")]),t._v(" "),e("p",[t._v("​\t\t\tLRU实现：使用双向链表LinkedHashMap实现。（HashMap是无序的，LinkedHashMap维护了迭代顺序。）")]),t._v(" "),e("p",[t._v("​\t\t\t1、新的数据插到链表头部")]),t._v(" "),e("p",[t._v("​\t\t\t2、缓存命中的时候，将数据移到链表头")]),t._v(" "),e("p",[t._v("​\t\t\t3、链表满的时候，将链表后面的数据丢弃。")]),t._v(" "),e("p",[e("strong",[t._v("6、缓存穿透、缓存击穿、缓存雪崩的解决方案？")])]),t._v(" "),e("p",[t._v("​\t\t缓存穿透：指定不存在的数据，存储层查不到数据则不写入缓存。导致这个不存在的数据每次请求都到DB去查询。可能导致DB挂掉。")]),t._v(" "),e("p",[t._v("​\t\t解决方案：1、将这个key缓存起来，设置较短的过期时间 2、一个Map来保存这些key，作为一个过滤器。如果有key，则不请求DB。")]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("​\t\t缓存击穿：一个设置了过期时间的key在某个时间点过期，刚好那时有大量请求该数据。导致全部请求到达DB，导致DB挂掉。")]),t._v(" "),e("p",[t._v("​\t\t解决方案：1、使用互斥锁，setnx()。当一个缓存失效时，请求先不请求DB，先加个互斥锁，其他线程等待。然后再请求DB数据缓存起来，释放锁后其它线程即可直接访问缓存了。2、永不过期")]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("​\t\t缓存雪崩：设置了很多"),e("strong",[t._v("相同过期时间")]),t._v("的热点数据，当过期时大量请求直接请求数据库，导致DB挂掉。")]),t._v(" "),e("p",[t._v("​\t\t解决方案：")]),t._v(" "),e("p",[t._v("​\t\t\t**事前：**1、在设置过期时间的时候可以设置加上一个随机值，防止大量key同时失效。2、搭建redis集群。")]),t._v(" "),e("p",[t._v("​\t\t\t**事后：**1、通过加锁或者入队列的方式对请求数据库和写缓存的线程进行限制。只允许一个线程查询数据和写入缓存。释放锁后其它线程即可查询新写入缓存的数据了。")]),t._v(" "),e("p",[e("strong",[t._v("7、选择缓存的时候，什么时候选redis，什么时候选择memcached？")])]),t._v(" "),e("p",[t._v("​\t\t选"),e("strong",[t._v("redis")]),t._v("：1、需要复杂的数据结构。2、需要数据持久化的功能。3、高可用场景，redis支持集群。可实现主动复制，读写分离。对于memcached要实现高可用，需进行二次开发。4、存储内容比较大，memcached存储的value最大为1M。")]),t._v(" "),e("p",[t._v("​\t\t选"),e("strong",[t._v("memcached")]),t._v("：1、纯K/V，数据量很大的业务。")]),t._v(" "),e("p",[e("img",{attrs:{src:"F:%5CtyporaImg%5C1582201193241.png",alt:"1582201193241"}})]),t._v(" "),e("p",[t._v("2、网络模型，memcached是非阻塞的IO复用模型。")]),t._v(" "),e("p",[t._v("3、线程模型，memcached使用多线程，主线程监听，worker子线程接收请求，执行读写。充分利用多核性能提升吞吐量。")]),t._v(" "),e("p",[e("strong",[t._v("8、缓存与数据库不一致怎么办？")])]),t._v(" "),e("p",[e("img",{attrs:{src:"F:%5CtyporaImg%5C1582201379625.png",alt:"1582201379625"}})]),t._v(" "),e("p",[e("strong",[t._v("9、主从数据库不一致怎么办？")]),e("img",{attrs:{src:"F:%5CtyporaImg%5C1582201558749.png",alt:"1582201558749"}})]),t._v(" "),e("p",[e("strong",[t._v("10、redis常见的性能问题和解决方案")]),e("img",{attrs:{src:"F:%5CtyporaImg%5C1582201614010.png",alt:"1582201614010"}})]),t._v(" "),e("p",[e("strong",[t._v("11、redis的数据淘汰策略有哪些？")])]),t._v(" "),e("p",[t._v("​\t\t"),e("strong",[t._v("voltile-lru")]),t._v(" 从设置过期时间的数据集中挑选"),e("strong",[t._v("最近最少使用")]),t._v("的数据淘汰。")]),t._v(" "),e("p",[t._v("​\t\t"),e("strong",[t._v("voltile-ttl")]),t._v(" 从设置了过期时间的数据集中挑选"),e("strong",[t._v("将要过期")]),t._v("的数据。")]),t._v(" "),e("p",[t._v("​\t\t"),e("strong",[t._v("voltile-random")]),t._v(" 从设置了过期时间的数据集中"),e("strong",[t._v("任意随机")]),t._v("选择淘汰数据。")]),t._v(" "),e("p",[t._v("​\t\t"),e("strong",[t._v("allkeys-lru")]),t._v(" 从数据集中挑选最近最少使用的数据淘汰。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("**allkeys-random** 从数据集中任意随机体挑选数据淘汰。\n")])])]),e("p",[t._v("​\t\t"),e("strong",[t._v("no-eviction")]),t._v(" 禁止驱逐数据。")]),t._v(" "),e("p",[e("strong",[t._v("13、redis中有一亿个key，其中有10w个key是以固定的已知前缀开头，如何找出来？")])]),t._v(" "),e("p",[t._v("​\t\t使用"),e("strong",[t._v("keys+通配符")]),t._v("的方法列出所有一直前缀的key ，比如前缀是like "),e("code",[t._v("keys like*")])]),t._v(" "),e("p",[t._v("​\t\t使用keys的问题：因为redis是单线程的，key数据量太大的话会阻塞一段时间才可进行其它业务")]),t._v(" "),e("p",[t._v("​\t\t更好的方式：使用"),e("strong",[t._v("scan")]),t._v("指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会"),e("strong",[t._v("有一定的重复概率")]),t._v("，需要去重。整体花费的时间比keys指令长。"),e("code",[t._v("scan 0 match *like")])]),t._v(" "),e("p",[e("strong",[t._v("14、redis怎么做异步队列，怎么实现？")])]),t._v(" "),e("p",[t._v("​\t\t使用list保存数据，rpush生产消息，lpop消费消息。当lpop没有消息时，可以sleep一段时间，再去检查。如果不用sleep的话，可以使用blpop，再没有消息的时候，会一直阻塞。知道消息到来。")]),t._v(" "),e("p",[t._v("​\t\t为什么blpop会阻塞？redis不是单线程的吗？其它命令还能执行吗")]),t._v(" "),e("p",[e("img",{attrs:{src:"F:%5CtyporaImg%5C1582203192441.png",alt:"1582203192441"}})]),t._v(" "),e("p",[e("strong",[t._v("15、redis如何实现延时队列？")])]),t._v(" "),e("p",[t._v("​\t\t使用"),e("strong",[t._v("sortedset")]),t._v("，使用时间戳作为score，消息内容作为key，调用zadd来生产消息。消费者使用"),e("strong",[t._v("zrangebyscore")]),t._v("获取n秒前的数据做轮询处理。")]),t._v(" "),e("p",[e("strong",[t._v("16、什么是redis？他的优缺点？")])]),t._v(" "),e("p",[t._v("​\t\tkey/value类型的内存数据库，缓存数据库。定期通过异步操作将数据flush到硬盘上保存。数据类型很多，可以利用这个特点做很多服务（消息队列，延时队列）。")]),t._v(" "),e("p",[t._v("​\t\t缺点：因内存的限制，不能用作海量数据的高性能读写。主要用于叫小数据量的高性能操作和运算上。")]),t._v(" "),e("p",[e("strong",[t._v("17、redis相比memcached的优势")]),e("img",{attrs:{src:"F:%5CtyporaImg%5C1582203771944.png",alt:"1582203771944"}})]),t._v(" "),e("p",[e("strong",[t._v("18、redis的集群方案应该怎么做？有哪些方案？")])]),t._v(" "),e("p",[t._v("Redis Cluster 是 Redis 的分布式解决方案，在 Redis 3.0 版本正式推出的。")]),t._v(" "),e("p",[t._v("Redis Cluster 去中心化，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。")]),t._v(" "),e("p",[e("strong",[t._v("Redis Cluster 节点分配")])]),t._v(" "),e("p",[t._v("参考：https://www.jianshu.com/p/26e61d1161af")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 在redis安装目录常见cluster文件夹，在创建端口对应文件夹和配置文件\n// 安装命令\nredis-server --service-install cluster/7100/redis.7100.conf --service-name redis7100\n// 卸载命令\nredis-server --service-uninstall --service-name redis7100\n// 启动命令\nredis-server --service-start --service-name redis7100\n// 停止命令\nredis-server --service-stop --service-name redis7100\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br")])]),e("p",[t._v("Redis Cluster 特点：")]),t._v(" "),e("ol",[e("li",[t._v("所有的 redis 节点彼此互联(PING-PONG 机制)，内部使用二进制协议优化传输速度和带宽。")]),t._v(" "),e("li",[t._v("节点的 fail 是通过集群中超过半数的节点检测失效时才生效。")]),t._v(" "),e("li",[t._v("客户端与 redis 节点直连,不需要中间 proxy 层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。")]),t._v(" "),e("li",[t._v("redis-cluster 把所有的物理节点映射到[0-16383] 哈希槽 (hash slot)上（不一定是平均分配）,cluster 负责维护 node、slot、value。")]),t._v(" "),e("li",[t._v("Redis 集群预分好 16384 个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384 的值，决定将一个 key 放到哪个桶中。")])]),t._v(" "),e("p",[e("strong",[t._v("Redis Cluster 主从模式")])]),t._v(" "),e("p",[t._v("Redis Cluster 为了保证数据的高可用性，加入了主从模式。")]),t._v(" "),e("p",[t._v("一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份。当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。所以，在集群建立的时候，一定要为每个主节点都添加了从节点。")]),t._v(" "),e("hr"),t._v(" "),e("p",[e("strong",[t._v("Redis Sentinel")])]),t._v(" "),e("p",[t._v("Redis Sentinel 用于管理多个 Redis 服务器，它有三个功能：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("监控（Monitoring）")]),t._v("  - Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。")]),t._v(" "),e("li",[e("strong",[t._v("提醒（Notification）")]),t._v("  - 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。")]),t._v(" "),e("li",[e("strong",[t._v("自动故障迁移（Automatic failover）")]),t._v("  - 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。")])]),t._v(" "),e("p",[t._v("Redis 集群中应该有奇数个节点，所以至少有三个节点。")]),t._v(" "),e("p",[t._v("哨兵监控集群中的主服务器出现故障时，需要根据 quorum 选举出一个哨兵来执行故障转移。选举需要 majority，即大多数哨兵是运行的（2 个哨兵的 majority=2，3 个哨兵的 majority=2，5 个哨兵的 majority=3，4 个哨兵的 majority=2）。")]),t._v(" "),e("p",[t._v("假设集群仅仅部署 2 个节点")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("+----+         +----+| M1 |---------| R1 || S1 |         | S2 |+----+         +----+\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("如果 M1 和 S1 所在服务器宕机，则哨兵只有 1 个，无法满足 majority 来进行选举，就不能执行故障转移。")]),t._v(" "),e("p",[e("strong",[t._v("redis-cluster通信协议")])]),t._v(" "),e("p",[t._v("redis cluster节点间采取gossip协议进行通信")]),t._v(" "),e("p",[t._v("gossip协议包含多种消息，包括ping，pong，meet，fail等等。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信；")])]),t._v(" "),e("li",[e("p",[t._v("ping：每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据；")])]),t._v(" "),e("li",[e("p",[t._v("pong: 返回ping和meet，包含自己的状态和其他信息，也可以用于信息广播和更新；")])]),t._v(" "),e("li",[e("p",[t._v("fail: 某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。")])])])])}),[],!1,null,null,null);v.default=_.exports}}]);